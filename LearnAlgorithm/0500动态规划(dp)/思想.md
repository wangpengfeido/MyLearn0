## 认识
### 递推
计算第i项的值时，由i-n项的值递推出来。

### 记忆化搜索
计算第i项的值时，需要用到第j项的值(j\<i)。第j项的值查表得到，如果表中存在则直接使用，不存在则递归计算。

### 状态和状态转移
首先要设计出合适的状态，然后通过状态的特征建立状态转移方程。

### 最优化原理和最优子结构
如果问题的最优解包含的子问题的解也是最优的，就称该问题具有最有子结构，即满足最优化原理。

### 决策无后效性
一旦某个状态确定后，它之前的状态无法对它之后的状态产生影响。

## 经典模型
### 线性模型
状态的排布是呈线性的。

### 区间模型
区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。

状态一般表示为d[i][j]，表示区间[i,j]上最优解。

### 背包模型

#### 0/1背包
有 N 种物品（每种一件），容量为 V 的背包。放入第 i 种物品耗费的空间为C[i]，得到的价值是 W[i] ，求可获得最大价值。

假设 f[i][v]表示将 i 种物品放入容量为 v 的背包可获得的最大价值。

在放第 i 个物品的时候，可以选择放或不放，所以状态转移方程：
````
f[i][v] = max{ f[i-1][v], f[i-1][v-C[i]]+W[i] }
````

时间复杂度为 O(VN)，空间复杂度为 O(VN)。空间复杂度可使用滚动数组优化为 O(V)

#### 完全背包
有 N 种物品（每种无限件），容量为 V 的背包。放入第 i 种物品耗费的空间为C[i]，得到的价值是 W[i] ，求可获得最大价值。

假设 f[i][v]表示将 i 种物品放入容量为 v 的背包可获得的最大价值。k 为第 i 中物品放入的件数。

所以状态转移方程：
````
f[i][v] = max{ f[i-1][v-kC[i]]+kW[i] | 0<=k<=v/C[i] }
````

实际上，当 k 取值为 0 或 1 时，就是0/1背包的状态转移方程。

时间复杂度为 O(VNsum(V/C[i])) ，空间复杂度在使用滚动数组优化后为 O(V)

进行优化后，状态转移方程可变成：（TODO:）
````
f[i][v] = max{ f[i-1][v], f[i][v-C[i]]+W[i] }
````

时间复杂度降为 O(VN)

#### 多重背包
有 N 种物品（每种 M[i] 件），容量为 V 的背包。放入第 i 种物品耗费的空间为C[i]，得到的价值是 W[i] ，求可获得最大价值。

假设 f[i][v]表示将 i 种物品放入容量为 v 的背包可获得的最大价值。k 为第 i 中物品放入的件数。

所以状态转移方程：
````
f[i][v] = max{ f[i-1][v-kC[i]]+kW[i] | 0<=k<=M[i] }
````

时间复杂度为 O(Vsum(M[i]))，空间复杂度在使用滚动数组优化后为 O(V)

优化：使用二进制拆分物品，将 M[i] 个物品拆分成容量为````1, 2, 4, 8, ..., 2^k, M[i]-(2^(k+1)-1)````个，对应价值为````W[i], 2W[i], 4W[i], 8W[i], ..., 2^k*W[i], M[i]-(2^(k+1)-1)*W[i]````，然后采用0/1背包求解

优化后的时间复杂度为 O(Vsum(logM[i])


